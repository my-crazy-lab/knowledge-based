# The Trouble with Distributed Systems

- cần biết phần mềm phản ứng như thế nào trước sự cố mạng và đảm bảo hệ thống có thể phục hồi
- Một số ứng dụng nhạy cảm với độ trễ, chẳng hạn như hội nghị truyền hình và Voice over IP (VoIP), sử dụng giao thức UDP thay vì TCP. Đây là một sự đánh đổi giữa độ tin cậy và độ biến thiên của độ trễ: do UDP không thực hiện điều khiển luồng và không truyền lại các gói tin bị mất, nên nó tránh được một số nguyên nhân gây ra độ trễ mạng thay đổi

## Synchronous Versus Asynchronous Networks

- Các hệ thống phân tán sẽ đơn giản hơn rất nhiều nếu chúng ta có thể dựa vào mạng để truyền gói tin với một độ trễ tối đa cố định và không mất gói. Tại sao không giải quyết vấn đề này ở tầng phần cứng để phần mềm không cần phải lo lắng?
- Chuyen mach mach nhu di dong se gioi han goi tin (16bit) nen khong co do tre do hang doi, nhung chuyen mach goi(TCP) giup linh hoach va tan dung bandwidth tot hon

## Clocks

- Trong hệ thống phân tán, thời gian là một vấn đề phức tạp
- mỗi máy trong mạng có đồng hồ riêng của mình, là một thiết bị phần cứng thực sự – thường là bộ dao động tinh thể thạch anh
- Những thiết bị này không hoàn toàn chính xác, do đó mỗi máy có một khái niệm thời gian hơi nhanh hoặc chậm hơn các máy khác
- có thể đồng bộ hóa các đồng hồ ở một mức độ nhất định: cơ chế được sử dụng phổ biến nhất là Giao thức Thời gian Mạng (NTP), 
    - ác máy chủ này lấy thời gian từ các nguồn chính xác hơn, chẳng hạn như thiết bị GPS.
- Máy tính hiện đại thường có ít nhất hai loại đồng hồ: đồng hồ theo giờ (time-of-day clock) và đồng hồ monotonic.

### Đồng hồ theo giờ (time-of-day clock)

- trả về ngày và giờ hiện tại theo lịch
- thường được đồng bộ bằng NTP, nghĩa là một timestamp từ một máy (lý tưởng) có cùng ý nghĩa với timestamp từ máy khác. 
- loại đồng hồ này có nhiều điểm kỳ lạ, ví dụ:
    - Nếu đồng hồ máy vượt xa máy chủ NTP, nó có thể bị thiết lập lại đột ngột, dẫn đến nhảy ngược về thời gian trước đó.
    - Đồng hồ này cũng bỏ qua giây nhuận, khiến nó không phù hợp để đo khoảng thời gian.

### Đồng hồ monotonic

- phù hợp để đo khoảng thời gian, chẳng hạn như timeout hoặc thời gian phản hồi của dịch vụ
- Đặc điểm nổi bật của nó là: nó luôn tiến về phía trước (không bao giờ nhảy ngược như đồng hồ theo giờ).
- Tuy nhiên, giá trị tuyệt đối của đồng hồ này không có ý nghĩa cụ thể
    - Không nên so sánh đồng hồ monotonic giữa hai máy, vì chúng không đồng bộ và không có cùng gốc thời gian.
- NTP có thể điều chỉnh tốc độ đồng hồ monotonic (gọi là slewing), để bù trừ khi máy chạy nhanh hoặc chậm, nhưng nó không làm nhảy đồng hồ về phía trước hoặc sau

### Clock Synchronization and Accuracy

- Đồng hồ monotonic không cần đồng bộ hóa.
- Đồng hồ theo giờ phải được đồng bộ với NTP hoặc nguồn ngoài để có ích.
- Tuy nhiên, việc đồng bộ không đáng tin cậy như bạn tưởng – cả phần cứng và NTP đều có thể trục trặc:
    - Đồng hồ thạch anh không chính xác: tốc độ lệch theo nhiệt độ. Google giả định sai số 200 ppm (~6 ms mỗi 30 giây, hoặc ~17 giây mỗi ngày).
    - Nếu đồng hồ lệch quá xa so với máy chủ NTP, nó có thể từ chối đồng bộ hoặc nhảy cóc thời gian, gây lỗi cho ứng dụng.
    - Một máy có thể bị cấu hình sai (hoặc bị firewall chặn NTP) mà không ai biết.
    - NTP chỉ chính xác nếu mạng tốt. Khi mạng chậm, có thể sai lệch 35 ms hoặc thậm chí lên đến 1 giây.
    - Một số máy chủ NTP báo sai giờ (sai hàng giờ), nhưng NTP client có thể chống chịu bằng cách bỏ qua những máy lệch quá xa.
    - Giây nhuận (leap seconds) có thể tạo ra một phút dài 59 hoặc 61 giây – nhiều hệ thống đã sập vì giây nhuận. Một số NTP server "nói dối" để tránh vấn đề (gọi là smearing, phân tán giây nhuận trong một ngày).
    - Trong máy ảo, đồng hồ là ảo hóa – khi CPU bị chia sẻ, một VM có thể "đứng yên" rồi nhảy vọt thời gian khi trở lại.
    - Trên các thiết bị không thể kiểm soát hoàn toàn (như điện thoại, thiết bị nhúng), người dùng có thể cố tình đặt sai giờ để gian lận.


